function getStandardizedServiceContractData() {
    console.time('getStandardizedServiceContractData');
    var id = 'standardizedServiceContract';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    
    var htmlmsg = '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'The agility promised by a service-oriented architecture (SOA) is usually measured in terms of the reusability level of its contained services. '
    htmlmsg += 'However, this reusability relates directly to the way the service contract defines service capabilities. '
    htmlmsg += 'A service built on a potentially reusable functional context but with a contract that does not convey this reusability correctly does not achieve its reusability potential.';
    htmlmsg += '</p>';
    htmlmsg += '<p>';
    htmlmsg += 'Within service-oriented solutions, a service contract represents a fundamental artifact, as this is the only medium through which services interact with each other or other consumer programs. ';
    htmlmsg += 'This creates a strong need to standardize the service contracts in order to make services reusable and recomposable as much as possible. ';
    htmlmsg += 'In order to achieve this, the standardized service contract design principle needs to be applied as its application results in standardized service contracts that are based on design standards as set within a service inventory.';
    htmlmsg += '</p>';
    htmlmsg += '<p>';
    htmlmsg += 'One of its goals is to reduce the need for data transformations as two services interact with each other, which can be achieved if the service contracts use standardized data models ';
    htmlmsg += 'e.g.XML schemas if the services have been implemented as web services. ';
    htmlmsg += 'This also helps in making services more interoperable.Another important goal of this design pattern is to use a standardized way of expressing service capabilities so that their purpose and ability can be easily understood at design time.';
    htmlmsg += '</p>';
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'A technical service contract is usually composed of a WSDL document, XML schema(s) and policy document(s). ';
    htmlmsg += 'Consequently, this principle needs to be applied across three areas of a service contract as described below:';
    htmlmsg += '</p>';
    htmlmsg += '<h4>Functional expression standardization</h4>';
    htmlmsg += '<p>';
    htmlmsg += 'The services operations need to be defined using standardized naming conventions. ';
    htmlmsg += 'This would also apply to the constituent input and out message names and their corresponding type names. ';
    htmlmsg += 'This helps to increase the service contracts correct interpretation, which in turn increases services reuse and interoperability. '
    htmlmsg += 'When service contracts clearly express their capabilities, the chance of service duplication is also reduced.';
    htmlmsg += '</p>';
    htmlmsg += '<h4>Data model standardization</h4>';
    htmlmsg += '<p>';
    htmlmsg += 'Two services exchanging messages based on the same type of data—e.g., a purchase order—might model that data according to different schemas, which requires data model transformation. ';
    htmlmsg += 'This clearly adds overhead, and stands in the way of service interoperability and reuse. ';
    htmlmsg += 'To avoid this transformation, the standardized service contract principle requires standardized data models, ';
    htmlmsg += 'which further helps create a standardized data representation architecture that can be reused across the enterprise to define standardized service capabilities. ';
    htmlmsg += 'Schema centralization directly supports the objectives of data model standardization design pattern, which further supports creation of centrally governed schemas.';
    htmlmsg += '</p>';
    htmlmsg += '<h4>Policy standardization</h4>';
    htmlmsg += '<p>';
    htmlmsg += 'Service policies represent terms of use for a service. ';
    htmlmsg += 'So, for a service to be reusable, its behavioral requirements must be expressed consistently using standardized policy expressions based on industry standard vocabularies. ';
    htmlmsg += 'This type of standardization further promotes separation of policies from service contracts into individual policy documents, which facilitates centralized governance. ';
    htmlmsg += 'In some cases, two policies, though syntactically different, might mean the same thing—therefore, design standards must dictate acceptable policy structure.'
    htmlmsg += '</p>';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'Application of this design principle depends on design standards at the service inventory level. ';
    htmlmsg += 'This requires additional resources, in terms of time and effort. ';
    htmlmsg += 'Secondly, to apply this design principle effectively, the actual contract must be physically isolated from the service logic and implementation so that it can be based on industry standards. ';
    htmlmsg += 'This can be achieved by the application of a decoupled contract design pattern. Also that the <strong>contract first</strong> approach needs to be followed so that the underlying logic only makes use of standardized data models. ';
    htmlmsg += 'Furthermore, the requirement for centralized data models may end in transmission of redundant data between services, as the actual data a service needs may be only a subset of the data defined in the standardized schema imposed on the service.';
    htmlmsg += '</p>';
    htmlmsg += '<h3>Implementation</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'The realality of this implementation is hard to measure as although we know about "ALL" services that comply with this principal, its impossible for us to track all services that do not. '; 
    htmlmsg += 'We do know of a subset of services that do not comply and these are represented in the graphs below. ';
    htmlmsg += 'The services that do not use the Datapower devices are impossible for us to track as they are simply unknown, undocumented, unused or all of the above. '; 
    htmlmsg += '</p>';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getStandardizedServiceContractData');
}
function getServiceLooseCouplingData() {
    console.time('getServiceLooseCouplingData');
    var id = 'serviceLooseCoupling';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'The concept of loose coupling within SOA is directly influenced by the object-oriented design paradigm, whereby the objective is to reduce coupling between classes in order to foster an environment where both the classes, ';
    htmlmsg += 'although somehow related to each other, can be changed in a manner that such a change does not break the existing relationship, which is necessary for the working of a software program. The same concept applies within SOA world as well, ';
    htmlmsg += 'however, within SOA particular emphasis is on the service contract as the service contract acts as an interface through which service consumers communicate with the service logic and vice versa. ';
    htmlmsg += 'Apart from this, SOA strongly advocates development of physically independent service contracts from the service logic (decoupled contract design pattern) in favor of interoperability and technology independence. ';
    htmlmsg += 'As the contracts are physically independent, there is a need to not only look into the coupling between service consumers and service contracts but also between service contracts and their underlying logic and implementation. ';
    htmlmsg += 'This is where the application of this design principle helps in identifying the various types of couplings that exist (inter service as well as intra service) and how to design the contracts in order to minimize negative coupling types ';
    htmlmsg += 'and maximize positive coupling types.'; 
    htmlmsg += 'A service-oriented solution that consists of services having loosely coupled contracts directly supports the increased vendor diversity options and increased interoperability goals of service-orientation.';
    htmlmsg += '</p>';
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += 'The application of the service loose coupling design principle requires delving into the different types of couplings that exist between the service consumer and the service contract as well as the service contract and the ';
    htmlmsg += 'services implementation. Only by understanding these different types, their impact on the service-orientation can be correctly analyzed.';
    htmlmsg += '<h4>Coupling types</h4>';
    htmlmsg += '<h5>Logic-to-contract</h5>';
    htmlmsg += 'Service loose coupling dictates that this kind of coupling should to be favored so that the service logic is developed exclusively in support of the service contract. ';
    htmlmsg += 'However, this requires following the <strong>contract first</strong> approach as advocated by the standardized service contract principle so that the service logic is coupled to a standardized contract. ';
    htmlmsg += 'This way the service contract is not coupled to the logic so the logic could be replaced in future if need be without affecting the service consumers.';
    htmlmsg += '<h5>Contract-to-logic</h5>';
    htmlmsg += 'This type of coupling exists when the contract is built based on existing logic e.g. through automated tools. ';
    htmlmsg += 'This is a negative form of coupling and needs to be avoided as it inhibits the evolution of service contract. ';
    htmlmsg += 'This is because the service contract is not designed independently according to the design standards and is dictated by the underlying logic.';
    htmlmsg += '<h5>Contract-to-implementation</h5>';
    htmlmsg += 'When contracts are designed in a manner that they are based on the underlying implementation details e.g. data models used within the underlying database, this results in a negative form of coupling that needs to be avoided. ';
    htmlmsg += 'This way, a change in the underlying implementation will require a corresponding change in the service contract. ';
    htmlmsg += 'This type of coupling can be reduced with the introduction of a façade component in between the service logic and its implementation as advocated by the Service Façade design pattern.';
    htmlmsg += '<h5>Contract-to-technology</h5>';
    htmlmsg += 'A contract that exposes proprietary technology elements used by the service logic e.g. a contract based on .NET Remoting technology, forms a negative form of coupling as the service consumers are limited to that particular technology. ';
    htmlmsg += 'This greatly hampers the service’s ability to be counted as an interoperable enterprise-resource.';
    htmlmsg += '<h5>Contract-to-functional</h5>';
    htmlmsg += 'This type of coupling normally exists when the service contract is developed by keeping a particular kind of consumer in mind ';
    htmlmsg += 'e.g. services built to enable communication with a business partner or a service that executes a part of the business process logic or is itself the parent controller service in a service composition that executes the business process logic. ';
    htmlmsg += 'This is also a negative form of coupling and needs to be avoided. ';
    htmlmsg += 'Although in case of agnostic services there is a clear need to reduce this coupling type, however, in case of non-agnostic services ';
    htmlmsg += 'e.g. the task services, existence of such coupling is intentional because the service is not required to be particularly reusable and hence could be tightly coupled to a particular consumer for better efficiency.';
    htmlmsg += '<h5>Consumer-to-implementation</h5>';
    htmlmsg += 'This is a negative form of coupling that exists because the service consumers access the service directly either via its logic or implementation. ';
    htmlmsg += 'This can happen because of number of reasons. For example, the service consumers used to access the current service through streamlined proprietary interfaces long before it actually existed as a service ';
    htmlmsg += 'i.e. before the move towards service-orientation. The application of the contract centralization design pattern helps to avoid this kind of coupling.';
    htmlmsg += '<h5>Consumer-to-contract</h5>';
    htmlmsg += 'This is a favorable type of coupling as it helps to evolve the service without impacting its consumers. ';
    htmlmsg += 'However, it is quite important to bear in mind that this coupling should only be restricted to the service contract and should not leak into the service architecture. ';
    htmlmsg += 'This could happen if all of the negative contract related coupling types are not addressed, consequently the service consumer can easily become coupled to the service implementation, logic or technology.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'Designing service contracts that are totally decoupled from their internal and external surroundings would no doubt result in services that are interoperable and scalable but on the other side, ';
    htmlmsg += 'this may create contracts that have capabilities which are too generic or the capabilities’ message exchange is too generic which would result in more roundtrips, requiring increased processing resources and time.';
    htmlmsg += 'Analyzing all of the above different types of coupling requires extra time and efforts and may increase the delivery time of services. ';
    htmlmsg += 'Consequently, there is a need to apply this design principle to a meaningful extent as set by the design standards within the individual organization.';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceLooseCouplingData');
}
function getServiceAbstractionData() {
    console.time('getServiceAbstractionData');
    var id = 'serviceAbstraction';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'A service contract that contains details about what it encapsulates (e.g., the logic, implementation and the technology used to build the service) ';
    htmlmsg += 'may end up being used in a particular manner by providing the service consumer more knowledge about the working of the service. In the case of service-orientation, more knowledge is not necessarily better. ';
    htmlmsg += 'There is a chance that additional information could impede the reusability of the service as the service consumer designer may streamline his design based on this knowledge. ';
    htmlmsg += 'However, doing so would affect the evolution of the service contract as now the service consumer is indirectly coupled to the service implementation, which may need to be replaced in the future. ';
    htmlmsg += 'This increases the consumer-to-contract type of coupling, which is a positive type of coupling. However, having too much dependence can negatively impact the evolution of both the service provider and the service consumer.';
    htmlmsg += 'Information hiding remains one of the key principles within object-oriented paradigm that promotes abstracting away the inner workings of a software program. ';
    htmlmsg += 'A classic example would be the use of abstract classes to hide the actual method logic. ';
    htmlmsg += 'The same concept is applied by the service abstraction principle in order to hide the unnecessary details about the working of the service with a view to ease the evolution of the service.';
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += 'The application of this design principle requires looking into four different types of abstractions that could be applied to a service.';
    htmlmsg += '<h4>Functional abstraction</h4>';
    htmlmsg += 'This form of abstraction is dependent upon how much of the service logic is exposed as service capabilities. An example would be of a class whereby some of its methods are private while others are public. ';
    htmlmsg += 'A class would only expose those methods as public that it deems to be important to its objects, any helper methods that are not relevant to the objects are kept hidden.';
    htmlmsg += 'A service contract which has not been subjected to this principle could be termed as a "detailed contract" that reveals much of business rules and the validation logic. ';
    htmlmsg += 'Once this principle has been applied to a fair degree, the contract could be termed as a ‘concise contract. ';
    htmlmsg += 'Further application of this design principle would result in a "optimized contract" that maximizes the reuse potential of the service.';
    htmlmsg += '<h4>Technology information abstraction</h4>';
    htmlmsg += 'Any information about the underlying technology used within the service would result in a low technology information ';
    htmlmsg += 'abstraction as the service contract explicitly tells the service consumers how the service logic and its implementation are designed. ';
    htmlmsg += 'This extra information might result in service consumers being designed in a way that specifically targets that particular implementation, thereby developing consumer-to-implementation coupling.';
    htmlmsg += '<h4>Logic abstraction</h4>';
    htmlmsg += 'The programmatic details about the service logic need to be abstracted as knowledge about how the service actually performs its functionality can result in service consumers that factor in this ';
    htmlmsg += 'information and are consequently designed under these assumptions. This can seriously hamper service logic refactoring efforts and can be considered as an anti-pattern towards the application of the service refactoring design pattern.';
    htmlmsg += '<h4>Quality abstraction</h4>';
    htmlmsg += 'Quality abstraction relates to the details provided within the service’s accompanying SLA. ';
    htmlmsg += 'It’s important to concentrate only on that kind of information that would actually help in determining the reliability and availability of the service, ';
    htmlmsg += 'no other information should be included that exposes unnecessary details e.g. details about how does a service sit within the overall business process and which other services it uses for fulfilling its functionality.';
    htmlmsg += 'The level of access control applied to a service would decide how much of technology, logic and Quality of service (QoS) abstractions are in place. ';
    htmlmsg += 'An "open access" would provide free access to everyone that is interested in finding out the design specifications of a service. ';
    htmlmsg += 'In a "controlled access", only authorized people are granted access and a "no access" policy would totally deny any access to the design documents.'
    htmlmsg += '<h4>Considerations</h4>';
    htmlmsg += 'Although information hiding is considered a healthy practice, however, too much of information hiding could be counter productive as it can limit the re-usability level of the service. ';
    htmlmsg += 'This can also result in redundant services as service designers don’t have enough information about the capabilities of the service. ';
    htmlmsg += 'For this, each service contract needs to be designed in a concise yet comprehensive manner so that the service’s capabilities can be effectively discovered and interpreted as dictated by the service discoverability principle.';
    htmlmsg += 'The kind of information exposed in the service contract can lead to some security related concerns as well. ';
    htmlmsg += 'For example, a service that propagates the details about the database in use as result of an internal error can fall a victim to an attack where the attacker makes use of the reported error details and attempts to connect to the database. ';
    htmlmsg += 'This could be addressed by the application of the message screening and Exception Shielding design patterns.';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceAbstractionData');
}
function getServiceReusabilityData() {
    console.time('getServiceReusabilityData');
    var id = 'serviceReusability';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '';
    htmlmsg += '<p>';
    htmlmsg += 'The service reusability principle is a design principle, applied within the service-orientation design paradigm, to create services that can be reused across a business.';
    htmlmsg += 'These reusable services are designed so that their solution logic is independent of any particular business process or technology.';
    htmlmsg += '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'Service reusability is typically measured by how much extra functionality a service contains that could be reused in future, and how much of the service’s functionality goes beyond the current requirements. ';
    htmlmsg += 'This encourages services that contain extra capabilities built around possible future service usage scenarios. ';
    htmlmsg += 'However, little is done in designing the service logic in a manner that it could be reused to automate multiple business processes. ';
    htmlmsg += 'This results in more focus on equipping services with extra functionality than concentrating on making the core service logic reusable, leading to gold-plated services whose development require increased time and efforts. ';
    htmlmsg += 'This additional functionality may not even fall within the original functional context of the service and might not even be used at all, as it was built without establishing its needs. ';
    htmlmsg += 'The resulting SOA would not be able to provide true service reusability as promised.';
    htmlmsg += 'Another misconception about service reuse is that the reuse relates to the frequency of its usage. ';
    htmlmsg += 'Contrary to this, the actual reuse relates to when the service is used to automate multiple business processes. ';
    htmlmsg += 'This is the true service reuse as such a service eliminates the need for creating altogether a new service and becomes a part of multiple business processes without being part of any particular business process.';
    htmlmsg += 'The service reusability principle addresses these misconceptions by providing a set of guidelines that help to design services containing logic which is not linked to any ';
    htmlmsg += 'particular business process and hence could be reused across the enterprise for automating multiple business processes. This further helps in achieving increased ROI.';
    htmlmsg += 'The compound application of service reusability, service abstraction and service loose coupling principles help developing composable services.'
    htmlmsg += '<h3>>Application</h3>';
    htmlmsg += 'This design principle advocates developing services based on the commercial product design principles that dictate developing a software product with the right type and correct quantity of logic. ';
    htmlmsg += 'So the focus here is on the quality of the logic packed within the software program. ';
    htmlmsg += 'By concentrating on quality, the reuse potential of the software program is automatically increased. ';
    htmlmsg += 'In order to concentrate on the quality of the logic, the service reusability requires exploring the business domain as well as the current technologies in use. ';
    htmlmsg += 'Some of the considerations that help in designing services with reusable logic include:';
    htmlmsg += '<ul>';
    htmlmsg += '<ol>What are the long term objectives of the organization?</ol>';
    htmlmsg += '<ol>Analyzing the functional contexts of the current services.</ol>';
    htmlmsg += '<ol>Current legacy systems and any future plans of decommissioning such legacy systems.</ol>';
    htmlmsg += '<ol>What are the current requirements that the service is required to address?</ol>';
    htmlmsg += '<ol>Details about the corresponding business domain(s).</ol>';
    htmlmsg += '</ul>';
    htmlmsg += 'By conducting this analysis, we can arrive at the right type of reusable logic that needs to be included within the service. Also because the other services are analyzed as well, the chances of logic duplication are minimized. ';
    htmlmsg += 'It is beneficial for the application of this principle to have a service inventory blueprint (a set of candidate services) as then the identification of agnostic logic becomes rather easier. ';
    htmlmsg += 'This requires performing via the Service-oriented analysis and design process. ';
    htmlmsg += 'The application of this principle before the finalization of service capabilities provides an opportunity for fine tuning and refactoring the logic in support of making it reusable. ';
    htmlmsg += 'This also gives a chance to equip the services with additional capabilities that could be reused by other business processes, apart from the one that is currently being automated, when it comes to automating such processes.';
    htmlmsg += 'An important concept related to the application of this principle is logic centralization. ';
    htmlmsg += 'With the passage of time, as different service delivery projects are undertaken, the chances of services containing duplicate logic increases. ';
    htmlmsg += 'This can only be avoided if there exists an enterprise wide standard that dictates analyzing the current services when it comes to appending services with new reusable logic. ';
    htmlmsg += 'If a service already exists with a functional context that fits the new reusable logic, then instead of creating a new service such a logic should become part of the existing service. ';
    htmlmsg += 'This not only helps in avoiding duplication but also increases the reusability level of the service as now the reusable logic sits within the correct context and hence stands a better chance of reuse. ';
    htmlmsg += 'This is exactly what is advocated by the logic centralization pattern.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'The application of this design principle requires performing a top-down service-oriented analysis process in order to arrive at a complete set of candidate services. ';
    htmlmsg += 'This clearly requires increased resources both in the form of time and efforts. The application of the Logic Centralization design pattern may introduce cultural issues ';
    htmlmsg += 'e.g. service developers showing reluctance in reusing other’s services, project managers not willing to incorporate use of existing services as it might need solution design adaptation, etc.';
    htmlmsg += 'By emphasizing service reuse, the reliability of the reusable services becomes an important issue as multiple service consumers depend on the same service. ';
    htmlmsg += 'Other design principles like service autonomy principle and service statelessness principle provide guidance in order to deal with reliability and availability related issues.';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceReusabilityData');
}
function getServiceAutonomyData() {
    console.time('getServiceAutonomyData');
    var id = 'serviceAutonomy';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '<h2>Service autonomy principle</h2>';
    htmlmsg += 'Service autonomy is a design principle that is applied within the service-orientation design paradigm, to provide services with improved independence from their execution environments. ';
    htmlmsg += 'This results in greater reliability, since services can operate with less dependence on resources over which there is little or no control.';
    htmlmsg += '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'The service-orientation design paradigm emphasizes service reuse as dictated by the service reusability design principle. ';
    htmlmsg += 'Under this paradigm of a heavily reused services, reliability becomes critical to ensure service longevity. ';
    htmlmsg += 'In turn, service reliability depends on the services operational control of service logic and underlying implementation resources to reduce dependence ';
    htmlmsg += 'on external resources over which it has little or no control such as shared service logic or a shared database, which may not be available when required by the service.';
    htmlmsg += 'Traditional component-based software development also faces the same autonomy requirements, the provisioning of autonomy and reliability, in such circumstances, is left to the actual run-time environment ';
    htmlmsg += 'e.g. by providing fail-over support or by deploying a solution on dedicated servers. ';
    htmlmsg += 'However, within service-orientation, the stakes are even higher as a service-oriented solution can be composed of services that exist outside of the organizational boundary. ';
    htmlmsg += 'So in this case, it’s the design of the service itself that matters and the service needs to be designed in a way that it exercises maximum control over how it fulfills its functionality. ';
    htmlmsg += 'The service autonomy principle attempts to provide guidelines for designing autonomous services so that the resulting services are more predictable and reliable.'
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += 'The application of service autonomy involves two types of autonomy that allow an increase the overall autonomy of the service, design time autonomy and run time autonomy.';
    htmlmsg += '<h4>Design-time autonomy</h4>'
    htmlmsg += 'Design-time autonomy refers to the independence with which the services could be evolved without impacting their service consumers. ';
    htmlmsg += 'This type of autonomy is required as the service’s underlying legacy resources might need an overhaul or the service’s logic might need refactoring in order to make it more efficient.';
    htmlmsg += 'The application of the service loose coupling and the service abstraction principles helps in attaining design-time autonomy as their application results in services whose contracts are shielded ';
    htmlmsg += 'from their logic and implementation and hence, the services could be redesigned without affecting their service consumers.';
    htmlmsg += '<h4>Run-time autonomy</h4>'
    htmlmsg += 'Run-time autonomy refers to the extent of the control that a service has over the way its solution logic is processed by the run-time environment. ';
    htmlmsg += 'The more control a service has over its run-time environment, the more predictable is its behavior. ';
    htmlmsg += 'Run-time autonomy is achieved by providing dedicated processing resources to the service. ';
    htmlmsg += 'For example, if the service logic performs memory intensive tasks then the service could be deployed to a server with reserved or conserved resources. ';
    htmlmsg += 'Similarly, by providing locally cached copies of data, where applicable, the service’s dependency on a remote shared database can be reduced. As a result, the overall autonomy of the service is increased...';
    htmlmsg += 'There is a direct relationship between run-time autonomy and the design-time autonomy. Increasing the design-time autonomy automatically increases the ability to evolve service’s implementation environment.';
    htmlmsg += '<h4>Service types</h4>';
    htmlmsg += 'Although increasing service autonomy to the maximum extent is always desirable, it is not always possible to design each and every service with maximum design-time and run-time autonomy. ';
    htmlmsg += 'As a result, the services need to be prioritized so that their autonomy could be addressed according to their value for business. ';
    htmlmsg += 'This could be done by having a look at the functional context of the service. Services whose functional contexts are independent of any particular business process, ';
    htmlmsg += 'e.g. entity and utility services, are good candidates for increasing their autonomy. ';
    htmlmsg += 'This is because they offer functionality that is of interest to different types of consumers. ';
    htmlmsg += 'On the other hand, business process specific services, e.g. task[6] and orchestrated task services, are less reusable and are dependent upon the individual autonomy of their composed services.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'The provisioning of service autonomy may require additional infrastructure and needs to be applied on a per-need, prioritized basis. ';
    htmlmsg += 'On some occasions, services may need to be isolated and deployed in a customized and dedicated environment, ';
    htmlmsg += 'with emphasis on designing the correct functional context since making fundamental changes to such a service is likely to be difficult.'
    htmlmsg += 'The autonomy of services that encapsulate legacy resources may be hard to predict and increase. ';
    htmlmsg += 'This may require additional analysis on part of utility services, as the level of autonomy depends upon the functionality provided by the service.';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceAutonomyData');
}
function getServiceStatelessnessData() {
    console.time('getServiceStatelessnessData');
    var id = 'serviceStatelessness';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '<h2>Service statelessness principle</h2>';
    htmlmsg += 'Service statelessness is a design principle that is applied within the service-orientation design paradigm, in order to design scalable services by separating them from their state data whenever possible. ';
    htmlmsg += 'This results in reduction of the resources consumed by a service as the actual state data management is delegated to an external component or to an architectural extension. ';
    htmlmsg += 'By reducing resource consumption, the service can handle more requests in a reliable manner.';
    htmlmsg += '<h3>Purpose</h3>';
    htmlmsg += '<p>';
    htmlmsg += 'The interaction of any two software programs involves keeping track of the interaction-specific data as each subsequent interaction may depend upon the outcome of the previous interaction. ';
    htmlmsg += 'This becomes more important in distributed architectures where the client and the server do not exist physically on the same machine. ';
    htmlmsg += 'In two-tier architectures, the responsibility of tracking this interaction-specific data rested upon the rich clients, which was not an issue as each client used to reside on an individual computer. ';
    htmlmsg += 'However, within n-tier architectures, the state management responsibility shifted from the client to the application or the web server. ';
    htmlmsg += 'This introduced the need for some middleware state management extensions so that the server could handle multiple concurrent client requests by deferring the actual activity-specific state data to such extensions ';
    htmlmsg += 'e.g. storing session data in a database in ASP .NET applications. This helps freeing up the memory resources in favor of increasing server responsiveness and the ability to entertain more client requests.';
    htmlmsg += 'In a service composition, a service may need to store activity-specific data in memory while it is waiting for another service to complete its processing. ';
    htmlmsg += 'Consequently, in case of service-orientation, an efficient management of service activity related data becomes more important as service-orientation puts a lot of emphasis on service reuse. ';
    htmlmsg += 'The service not only needs to deal with managing state data, which is created as a result of interacting with a consumer program, ';
    htmlmsg += 'in the context of a particular business process but also in relation to the interactions with other types of consumer programs that are part of multiple business processes. ';
    htmlmsg += 'As reusability goes up, so does the overhead of managing state data. ';
    htmlmsg += 'The Service Statelessness principle provides guidelines in favor of making the service stateless by shifting away the state management overhead from the services to some other external architectural component. ';
    htmlmsg += 'This further helps in the overall scalability of the service-oriented solution.';
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += 'The correct application of service statelessness requires an understanding of the various types of state information that need to be managed.';
    htmlmsg += '<h4>Context data</h4>';
    htmlmsg += 'Within a service composition, service may be required to keep track of data that is specific to the running of a particular service activity, which is usually linked with the coordination of messages, ';
    htmlmsg += 'e.g. workflows, and the associated rules that govern how the rules are to be interpreted.';
    htmlmsg += '<h4>Business data</h4>';
    htmlmsg += 'This is the data that relates to the actual business process, run by the current service activity e.g. customer records, etc. ';
    htmlmsg += 'on some occasions this type of data may need to be temporarily stored, especially if it acts as an input to the next stage within the service activity.'
    htmlmsg += '<h4>Session data</h4>';
    htmlmsg += 'This relates to the connection information between the services e.g. when consumer programs and services are communicating back and forth, ';
    htmlmsg += 'some sort of correlation may be required in order to fire the subsequent request only to the particular instance of the service as only that instance knows about the previous service interaction.';
    htmlmsg += '<h4>Statelessness and service types</h4>';
    htmlmsg += 'The Service Statelessness principle could be applied to varying extents in relation to the type of the solution logic enclosed by the service.';
    htmlmsg += '<h4>Task services</h4>';
    htmlmsg += 'The task services contain solution logic that is specific to a particular business process and hence their reuse level is low. ';
    htmlmsg += 'However, these services contain context data (workflow rules) about the service activity, which is directly proportional to the size of the service composition that is being administered by the task service. ';
    htmlmsg += 'As a result, designing such services with state deferral options reduces their memory footprint and makes them more responsive.';
    htmlmsg += '<h4>Utility services</h4>';
    htmlmsg += 'These kinds of services may need to be stateful in order to provide statelessness for task and entity services. ';
    htmlmsg += 'On the other hand, a highly reusable utility service, e.g. a utility service that acts as a wrapper for a legacy system, needs to be moderately stateless so that it can entertain multiple concurrent requests.';
    htmlmsg += '<h4>Entity services</h4>';
    htmlmsg += 'Being independent of any specific business process, these services are regarded as the most reusable services. ';
    htmlmsg += 'Another important factor is that they process data related to business entities and as such require higher levels of statelessness so that they are not burdened with keeping track of business data ';
    htmlmsg += 'that they may need to retain in order to provide the required functionality.';
    htmlmsg += 'The statelessness could either be achieved by delegating state management to some shared architectural extension, ';
    htmlmsg += 'e.g. a middleware product that exists outside of the service implementation boundary or to a dedicated mechanism that exists inside the service boundary e.g. a dedicated database.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'It may not always be possible to provide a dedicated state deferral option for each service as this clearly requires additional investment. On the other hand, ';
    htmlmsg += 'using a shared state deferral option may create a dependency for the service, which may stand in way of service evolution.';
    htmlmsg += 'The storage and retrieval of state information may inadvertently affect the response time of the service as both of these tasks may prove computationally ';
    htmlmsg += 'intensive as first the data needs to be converted into the native format of the storage extension and vice versa when it comes to retrieving the same information.';
    htmlmsg += 'Designing stateless services requires extra efforts and time as the service needs to contain logic that interfaces with the state deferral extensions. This in turn would require additional code and testing.';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceStatelessnessData');
}
function getServiceDiscoverabilityData() {
    console.time('getServiceDiscoverabilityData');
    var id = 'serviceDiscoverability';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '<h2>Discoverability</h2>';
    htmlmsg += 'Discoverability is the degree to which of something, especially a piece of content or information, can be found in a search of a file, database, or other information system. ';
    htmlmsg += 'Discoverability is a concern in library and information science, many aspects of digital media, software and web development, and in marketing, since something ';
    htmlmsg += '(e.g., a website, product, service, etc.) cannot be used if people cannot find it or do not understand what it can be used for. Metadata, or "information about information," ';
    htmlmsg += 'such as a books title, a products description, or a websites keywords, affects how discoverable something is on a database or online. ';
    htmlmsg += 'In the 2010s, adding metadata to a product that is available online can make it easier for end users to find the product. ';
    htmlmsg += 'For example, if a song file is made available online, making the title, name of the band, genre, year of release, and other pertinent information available in connection with this song file will make it easier for users to find this song file. ';
    htmlmsg += 'Organizing information by putting it into alphabetical order or including it in a search engine is an example of how to improve discoverability. ';
    htmlmsg += 'Discoverability is related to, but different from, accessibility and usability, other qualities that affect the usefulness of a piece of information.';
    htmlmsg += 'The concept of "discoverability" in an information science and online context is a loose borrowing from the concept of the similar name in the legal profession. ';
    htmlmsg += 'In law, "discovery" is a pre-trial procedure in a lawsuit in which each party, through the law of civil procedure, ';
    htmlmsg += 'can obtain evidence from the other party or parties by means of discovery devices such as a request for answers to interrogatories, request for production of documents, request for admissions and depositions. ';
    htmlmsg += 'Discovery can be obtained from non-parties using subpoenas. When a discovery request is objected to, the requesting party may seek the assistance of the court by filing a motion to compel discovery.';
    htmlmsg += '<h3>Purpose</h3>';
    htmlmsg += 'The usability of any piece of information directly relates to how discoverable it is, either in a "walled garden" database or on the open Internet. ';
    htmlmsg += 'The quality of information available on this database or on the Internet depends upon the quality of the meta-information about each item, product, or service. ';
    htmlmsg += 'In the case of a service, because of the emphasis placed on service reusability, opportunities should exist for reuse of this service. '
    htmlmsg += 'However, reuse is only possible if information is discoverable in the first place. To make items, products, and services discoverable, the following set of activities need to be performed:';
    htmlmsg += 'Document the information about the item, product or service (the metadata) in a consistent manner.';
    htmlmsg += 'Store the documented information (metadata) in a searchable repository.';
    htmlmsg += 'Enable yourself and others to search for the documented information in an efficient manner.';
    htmlmsg += 'Regarding number 2, storing the information in a searchable repository: while technically a human-searchable repository, such as a printed paper list would qualify, in the 2010s, ';
    htmlmsg += '"searchable repository" is usually taken to mean a computer-searchable repository, such as a database that a human user can search using some type of search engine or "find" feature. ';
    htmlmsg += 'Number 3 further supports this analysis of number 2, because while reading through a printed paper list by hand might be feasible in a theoretical sense, it is not time and cost-efficient in comparison with computer-based searching.';

    htmlmsg += 'Apart from increasing the reuse potential of the services, discoverability is also required to avoid development of solution logic that is already contained in an existing service. ';
    htmlmsg += 'To design services that are not only discoverable but also provide interpretable information about their capabilities, the service discoverability principle provides guidelines that could be ';
    htmlmsg += 'applied during the service-oriented analysis phase of the service delivery process.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'The effective application of this design principle requires that the meta-information recorded against each service needs to be consistent and meaningful.'; 
    htmlmsg += 'This is only possible if organization-wide standards exist that enforce service developers to record the required meta-data in a consistent way. ';
    htmlmsg += 'The information recorded as the meta-data for the service needs to be presented in a way so that both technical and non-technical IT experts can understand the purpose and the capabilities of the service,'; 
    htmlmsg += 'as an evaluation of the service may be required by the business people before the service is authorized to be used. ';
    htmlmsg += '<p>';
    htmlmsg += 'This principle is best applied during the service-oriented analysis phase as during this time, all the details about the service’s purpose and functionality are available. '; 
    htmlmsg += 'Although most of the service design principles support each other in a positive manner, however, in case of service abstraction and service discoverability principle, there exists an inversely proportional relationship.'; 
    htmlmsg += 'This is because as more and more details about the service are hidden away from the service consumers, less discoverable information is available for discovering the service. ';
    htmlmsg += 'This could be addressed by carefully recording the service meta-information so that the inner workings of the service are not documented within this meta-information.';
    htmlmsg += '';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceDiscoverabilityData');
}
function getServiceComposabilityData() {
    console.time('getServiceComposabilityData');
    var id = 'serviceComposability';
    var headerID = id + 'Header';
    var contentID = id + 'Content';
    var htmlmsg = '';
    htmlmsg += 'In computing, service composability is a design principle, applied within the service-orientation design paradigm, ';
    htmlmsg += 'that encourages the design of services that can be reused in multiple solutions that are themselves made up of composed services.'; 
    htmlmsg += 'The ability to recompose the service is ideally independent of the size and complexity of the service composition.';
    htmlmsg += 'This principle is directly responsible for the agility promised by SOA as it promotes composing new solutions by reusing existing services.';
    htmlmsg += '<h3>Purpose</h3>';
    htmlmsg += 'The concept of developing software out of independently existing components encourages the concept of composition.'; 
    htmlmsg += 'This is the underlying concept within object-orientation where the end product is composed of several interlinked objects that have the ability to become part of multiple software solutions,'; 
    htmlmsg += 'no matter how complex the solution is. The same composition concept is inherited by service-orientation, whereby a business process is automated by combining multiple services. ';
    htmlmsg += 'However, within service-orientation there is even greater focus on building services that can be composed and recomposed within multiple solutions to provide the agility promised by the SOA. ';
    htmlmsg += 'As a result of this emphasis, some guidelines are required to develop services that can be effectively aggregated into multiple solutions.';
    htmlmsg += 'The service composability principle provides design considerations that help towards designing composable services with a view to encourage service reuse as much as possible. ';
    htmlmsg += 'The guidelines provided by this principle prepare the service so that it is ready to participate in service compositions without requiring any further design changes.';
    htmlmsg += '<h3>Application</h3>';
    htmlmsg += 'The application of the service composability principle requires designing services so that they can be used in a service composition either as a service that controls other services,'; 
    htmlmsg += 'i.e. a controller service, or as a service that provides functionality to other services in the composition without further composing other services, i.e. a composition member.';
    htmlmsg += 'For the service to provide this dual functionality, the service contract[3] must be designed so that it presents functionality based on varying levels of input and output data. ';
    htmlmsg += 'In case if it is required to participate as a composition member, then usually the input parameters to the service would be more fine grained as compared to the situation when it is required to participate as a composition controller.'; 
    htmlmsg += 'A heavily reused service must be as stateless as possible (service statelessness principle) so that it can provide optimum performance when composed within multiple service compositions.';
    htmlmsg += 'The effectiveness of this principle depends upon the extent to which rest of the design principles have been applied successfully. ';
    htmlmsg += 'The application of the standardized service contract principle makes the services interoperable with others, and helps to keep the composition design simpler by avoiding the need to perform runtime data model transformation.';
    htmlmsg += 'By applying the service loose coupling principle, a service could be recomposed with the confidence that it would not create any form of negative coupling with the other service in the composition. ';
    htmlmsg += 'The application of the service autonomy and the service statelessness principles increase the reliability and availability of the service so that it be reused in multiple service compositions with increased confidence.';
    htmlmsg += '<h3>Considerations</h3>';
    htmlmsg += 'For the service to be an efficient service controller as well as a service member, the underlying technology architecture needs to provide a runtime environment that is scalable and can support the statelessness required by the service.'; 
    htmlmsg += 'Similarly as the service compositions increase in size, the storage and retrieval of the context data, related to the runtime interaction of the services, ';
    htmlmsg += 'may need to be delegated to the runtime environment instead of the services managing this context data to make the service composition more efficient.';
    htmlmsg += 'As more and more service compositions are built, there is a tendency of getting dependent on a service that is highly reused. ';
    htmlmsg += 'This requires careful analysis during the design of the service compositions and considering alternate standby services for critical functionality. On the other hand, ';
    htmlmsg += 'it may become difficult to evolve a service that is now become a part of multiple service compositions. ';
    htmlmsg += 'This could be addressed by the application of the Concurrent Contracts design pattern that advocates maintaining multiple concurrent contracts for a service.';
    htmlmsg += 'This way the service can evolve while providing backward compatibility.';
    htmlmsg += 'Some of the factors that determine the composability potential of a service include:';
    htmlmsg += '<ul><li>Ability to provide functionality at different levels within a business process.</li>';
    htmlmsg += '<li>Message Exchange pattern</li>';
    htmlmsg += '<li>Whether the service supports transactions and rollback/compensation features.</li>';
    htmlmsg += '<li>Support for exception handling.</li>';
    htmlmsg += '<li>The availability of meta-data about service capabilities and behavior.</li></ul>';
    $('#' + contentID).html(htmlmsg);
    appendAccordionHeader(headerID, '');
    $("#serviceDesignPrinciplesAccordion" ).accordion( "refresh" );
    console.timeEnd('getServiceComposabilityData');
}